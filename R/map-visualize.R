# -----------------------------------------------------------------------------------------------------------------------
# Copyright (c) 2023, microgeo/Chaonan Li (licn@mtc.edu.cn).                                                            #
# The microgeo is distributed under the terms of the Modified BSD License.                                              #
# Full license is avaliable in the file LICENSE, distributed with this package.                                         #
# -----------------------------------------------------------------------------------------------------------------------

#' @title Plot a basic map of the research area
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is used to plot a basic map of the research area. All data for the visualizations should be
#' included in the <map> (a `SpatialPolygonsDataFrame` class).
#' @param map Geographic map with a class of `SpatialPolygonsDataFrame`.
#' @param var Variable used to fill map area. If there is only one polygon in the <map>, the value of this argument would
#' be ignored and the map area would be filled up by the <fill> (only one color value) or the first element of the <fill>
#' if there are mutiple color values in the <fill>. Default is `NULL`.
#' @param ord Character vector for the display order if the <var> is a `character` or `factor`. Default is `NULL`.
#' @param fill A color value of a color vector used to fill the map region. This argument should not be `NA` if the <var>
#' is not `NULL` (You can set the <fill> as `'auto'`). If the <var> is a `number`, it is better to set a continuous color
#' vector for the <fill>, for example, `colorRampPalette(RColorBrewer::brewer.pal(11, 'RdYlGn'))(1000) %>% rev()`. If the
#' <var> is a `character` or `factor`, it is better to set a discrete color vector for the <fill>, e.g., the color vector
#' could be generated by `randomcoloR::randomColor(count = 1000)`. If the <fill> is `'auto'` and the <var> is not `NULL`,
#' the colors would be produced automatically based on the above described schema. Default is `NA`.
#' @param color Line color of border. Default is `gray30`.
#' @param width Line width of border. Default is `0.8`.
#' @param alpha Transparency of fill color. Default is `0.8`.
#' @param gg.theme The ggplot2 theme. Default is `theme_bw()`.
#' @param bg.color Color of panel background. Default is `white`.
#' @param gd.color Color of panel grid major. Default is `gray90`.
#' @param axis.text.size Size of axis text. Default is `12`.
#' @param legend.position Legend position. Select a value from `'right', 'left', 'top', 'bottom'` or set a numeric vector
#' like `c(0.1, 0.2)`. Default is `right`.
#' @param legend.title.size Text size of legend title. Default is `14`.
#' @param legend.text.size Text size of legend label. Default is `12`.
#' @param show.legend.rect Should the rectangle around the legend be displayed? Default is `FALSE`.
#' @return A ggplot2 object.
#' @examples
#' ##### Initialization of the visualizations #####
#' data(common.map.mean)
#' data(gridded.map.mean)
#' showtext::showtext_auto(enable = TRUE)
#'
#' ##### Example 1: plot maps without any fill color #####
#' common.map.mean  %>% plot_bmap()
#' gridded.map.mean %>% plot_bmap()
#'
#' ##### Example 2: plot maps filled by gray color #####
#' common.map.mean  %>% plot_bmap(fill = 'gray50', alpha = 0.5)
#' common.map.mean  %>% plot_bmap(fill = 'gray50', color = 'blue', alpha = 0.5)
#' gridded.map.mean %>% plot_bmap(fill = 'gray50', color = 'darkgreen', alpha = 0.5)
#'
#' ##### Example 3: plot maps automatically filled by the colors defined by a variable #####
#' common.map.mean  %>% plot_bmap(var = 'NAME', alpha = 0.5, fill = 'auto')
#' gridded.map.mean %>% plot_bmap(var = 'sample.num', fill = 'auto')
#' gridded.map.mean %>% plot_bmap(var = 'shannon_mean', fill = 'auto')
#' gridded.map.mean %>% plot_bmap(var = 'NAME', alpha = 0.5, fill = 'auto', legend.position = 'none')
#'
#' ##### Example 4: plot maps automatically filled by custom colors #####
#' common.map.mean  %>% plot_bmap(var = 'NAME', ord = c('西藏自治区', '青海省', '四川省'),
#'                                fill = RColorBrewer::brewer.pal(9, "Set1")[1:3])
#' common.map.mean  %>% plot_bmap(var = 'NAME', ord = c('四川省', '青海省', '西藏自治区'),
#'                                fill = RColorBrewer::brewer.pal(9, "Set1")[4:6])
#' gridded.map.mean %>% plot_bmap(var = 'NAME', legend.position = 'none',
#'                                fill = colorRampPalette(RColorBrewer::brewer.pal(11, 'BrBG'))(133) %>% rev)
#' gridded.map.mean %>% plot_bmap(var = 'sample.num',
#'                                fill = colorRampPalette(RColorBrewer::brewer.pal(11, 'BrBG'))(100) %>% rev)
#' gridded.map.mean %>% plot_bmap(var = 'shannon_mean',
#'                                fill = colorRampPalette(RColorBrewer::brewer.pal(11, 'BrBG'))(100) %>% rev)
#' gridded.map.mean %>% plot_bmap(var = 'shannon_mean', show.legend.rect = TRUE,
#'                                fill = colorRampPalette(RColorBrewer::brewer.pal(11, 'BrBG'))(100) %>% rev)
#' @export
plot_bmap = function(map, var = NULL, ord = NULL, fill = NA, color = 'gray30', width = 0.8, alpha = 0.8,
                     gg.theme = theme_bw(), bg.color = 'white', gd.color = 'gray90', axis.text.size = 12,
                     legend.position = c('right', 'left', 'top', 'bottom'), legend.title.size = 14,
                     legend.text.size = 12, show.legend.rect = FALSE){

    # Initialize the visualization
    map %>% check_mapdata()
    gg.theme %>% check_ggplot2_theme()
    legend.position %<>% get_legend_position()
    if (!var %>% is.null) map %>% check_map_var(., var)
    if (!var %>% is.null) cla.len <- map@data[,var] %>% unique() %>% length()
    if ('cla.len' %>% exists && cla.len == 1) var <- NULL

    # If the <map> is generated by `microgeo::merge_*_to_map()`, we remove the grids without sampling sites
    if ('sample.names' %in% colnames(map@data)){
        map.cp <- map; subset.map <- TRUE
        data.trim <- map@data[!map@data$sample.names %>% is.na,]
        map %<>% terra::subset(., map$NAME %in% data.trim$NAME)
    }

    # Automatically generate color values if `fill == 'auto' and `var != NULL`
    if (any(!is.na(fill)) && any(fill == 'auto') && !is.null(var) && is.numeric(map@data[,var])){
        fill <- colorRampPalette(RColorBrewer::brewer.pal(11, "RdYlGn"))(cla.len) %>% rev()
    }else if (any(!is.na(fill)) && any(fill == 'auto') && !is.null(var) &&
        (is.character(map@data[,var]) || is.factor(map@data[,var]))){
        fill <- randomcoloR::randomColor(count = cla.len)
    }

    # Visualize the research areas
    if (var %>% is.null){
        p.map <- ggplot() + geom_sf(data = sf::st_as_sf(map), fill = fill[1], color = color, size = width, alpha = alpha)
    }else{
        p.map <- ggplot() +
            geom_sf(data = sf::st_as_sf(map), aes(fill = .data[[var]]), color = color, size = width, alpha = alpha)
        msg <- "The <fill> should not be `NA` if the <var> is not `NULL`! You can set the <fill> as `'auto'`."
        if (fill %>% length == 1 && fill %>% is.na) msg %>% stop()
        if (map@data[,var] %>% is.character | map@data[,var] %>% is.factor){
            if (fill %>% length < cla.len) paste0('Requires at least ', cla.len, ' color values!') %>% stop()
            if (any(ord %>% is.null)) p.map <- p.map + scale_fill_manual(name = var, values = fill)
            if (any(!ord %>% is.null)) p.map <- p.map + scale_fill_manual(name = var, values = fill, breaks = ord)
        }else if (map@data[,var] %>% is.numeric){
            p.map <- p.map + scale_fill_gradientn(name = var, colours = fill, na.value = 'transparent')
        }else{
            stop('Unexpected error during the visualization!')
        }
    }
    if ('subset.map' %>% exists && subset.map){
        p.map <- p.map + geom_sf(data = sf::st_as_sf(map.cp), fill = NA, color = color, size = width)
    }
    p.map <- p.map +
        gg.theme + theme(legend.position = legend.position,
                         legend.background = element_blank(),
                         axis.text = element_text(size = axis.text.size),
                         panel.background = element_rect(fill = bg.color),
                         panel.grid.major = element_line(colour = gd.color),
                         legend.text = element_text(size = legend.text.size),
                         legend.title = element_text(size = legend.title.size))
    if (show.legend.rect) p.map %<>% add_legend_rect()
    return(p.map)
}

#' @title Plot a map for nearest neighbour interpolation
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is designed to visualize the results of nearest neighbour interpolation.
#' @param dat An R list returned by \code{microgeo::interp_nen()}.
#' @param fill Fill color of map area. Default is `rev(colorRampPalette(RColorBrewer::brewer.pal(11, 'RdYlGn'))(100))`.
#' @param color Line color of map border. Default is `gray50`.
#' @param alpha Transparency of fill color. Default is `0.8`.
#' @param width Line width of map border. Default is `0.8`.
#' @param size Size of axis text. Default is `12`.
#' @param gg.theme The ggplot2 theme. Default is `theme_bw()`.
#' @param bg.color Color of panel background. Default is `white`.
#' @param gd.color Color of panel grid major. Default is `gray80`.
#' @param legend.position Legend position. Select a value from `'right', 'left', 'top', 'bottom'` or set a numeric vector
#' like `c(0.1, 0.2)`. Default is `right`.
#' @param legend.title.size Text size of legend title. Default is `14`.
#' @param legend.text.size Text size of legend label. Default is `12`.
#' @param show.legend.rect Should the rectangle around the legend be displayed? Default is `FALSE`.
#' @return A ggplot2 object.
#' @seealso \code{\link[microgeo:interp_nen]{microgeo::interp_nen()}}
#' @examples
#' data(nen.interp)
#' nen.interp$shannon  %>% plot_nmap()
#' nen.interp$observed %>% plot_nmap()
#' nen.interp$observed %>% plot_nmap(show.legend.rect = TRUE)
#' nen.interp$observed %>% plot_nmap(fill = rev(colorRampPalette(RColorBrewer::brewer.pal(11, 'Spectral'))(100)))
#' @export
plot_nmap = function(dat, fill = colorRampPalette(RColorBrewer::brewer.pal(11, 'RdYlGn'))(100) %>% rev, color = 'gray50',
                     alpha = 0.8, width = 0.8, size = 12, gg.theme = theme_bw(), bg.color = 'white',
                     gd.color = 'gray80', legend.position = c('right', 'left', 'top', 'bottom'),
                     legend.title.size = 14, legend.text.size = 12,
                     show.legend.rect = FALSE){
    gg.theme %>% check_ggplot2_theme()
    legend.position %<>% get_legend_position()
    if (dat$type != 'nen') 'The `<dat>` must be the results returned by `microgeo::interp_nen()`!' %>% stop()
    p.map <- ggplot() +
        geom_sf(data = dat$res, aes(fill = target), size = width, colour = color, alpha = alpha) +
        scale_fill_gradientn(name = dat$var, colours = fill) + gg.theme +
        theme(legend.position = legend.position,
              legend.background = element_blank(),
              axis.text = element_text(size = size),
              panel.background = element_rect(fill = bg.color),
              panel.grid.major = element_line(colour = gd.color),
              legend.text = element_text(size = legend.text.size),
              legend.title = element_text(size = legend.title.size))
    if (show.legend.rect) p.map %<>% add_legend_rect()
    return(p.map)
}

#' @title Plot a map for inverse distance weighting (IDW) interpolation
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is used to visualize the results of inverse distance weighting (IDW) interpolation. It only
#' works when `<type> is 'hexagonal'` in running \code{microgeo::interp_idw()}.
#' @param dat An R list returned by \code{microgeo::interp_idw()}.
#' @param fill Fill color of map area. Default is `rev(colorRampPalette(RColorBrewer::brewer.pal(11, 'RdYlGn'))(100))`.
#' @param color Line color of map border. Default is `gray50`.
#' @param alpha Transparency of fill color. Default is `0.8`.
#' @param width Line width of map border. Default is `0.8`.
#' @param size Size of axis text. Default is `12`.
#' @param gg.theme The ggplot2 theme. Default is `theme_bw()`.
#' @param bg.color Color of panel background. Default is `white`.
#' @param gd.color Color of panel grid major. Default is `gray80`.
#' @param legend.position Legend position. Select a value from `'right', 'left', 'top', 'bottom'` or set a numeric vector
#' like `c(0.1, 0.2)`. Default is `right`.
#' @param legend.title.size Text size of legend title. Default is `14`.
#' @param legend.text.size Text size of legend label. Default is `12`.
#' @param show.legend.rect Should the rectangle around the legend be displayed? Default is `FALSE`.
#' @return A ggplot2 object.
#' @seealso \code{\link[microgeo:interp_idw]{microgeo::interp_idw()}}
#' @examples
#' data(idw.interp.hex)
#' idw.interp.hex$shannon$type # should be "idw_hex"
#' idw.interp.hex$shannon %>% plot_imap()
#' idw.interp.hex$observed %>% plot_imap()
#' idw.interp.hex$observed %>% plot_imap(show.legend.rect = TRUE)
#' idw.interp.hex$observed %>% plot_imap(fill = rev(colorRampPalette(RColorBrewer::brewer.pal(11, 'Spectral'))(100)))
#' @export
plot_imap = function(dat, fill = colorRampPalette(RColorBrewer::brewer.pal(11, 'RdYlGn'))(100) %>% rev, color = 'gray50',
                     alpha = 0.8, width = 0.8, size = 12, gg.theme = theme_bw(), bg.color = 'white', gd.color = 'gray80',
                     legend.position = c('right', 'left', 'top', 'bottom'), legend.title.size = 14,
                     legend.text.size = 12, show.legend.rect = FALSE){
    gg.theme %>% check_ggplot2_theme()
    legend.position %<>% get_legend_position()
    if (dat$type != 'idw_hex') 'The `<dat>` must be the results returned by `microgeo::interp_idw()`!' %>% stop()
    p.map <- ggplot() +
        geom_sf(data = dat$res, aes(fill = target), size = width, colour = color, alpha = alpha)+
        scale_fill_gradientn(name = dat$var, colours = fill) + gg.theme +
        theme(legend.position = legend.position,
              legend.background = element_blank(),
              axis.text = element_text(size = size),
              panel.background = element_rect(fill = bg.color),
              panel.grid.major = element_line(colour = gd.color),
              legend.text = element_text(size = legend.text.size),
              legend.title = element_text(size = legend.title.size))
    if (show.legend.rect) p.map %<>% add_legend_rect()
    return(p.map)
}

#' @title Add labels on a map
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is implemented to add label on a map. You can add any characters or numbers on the centroid
#' of polygons by using such a function.
#' @param map.layer A ggplot2 object of geographic map.
#' @param dat A `data.frame` containing the coordinates and the variable to be added on map.
#' @param lab.var Variable of labels to be shown (It should be included in the <dat>).
#' @param lab.col Color of label. Default is `black`.
#' @param lon.var Variable of longitude (It should be included in the <dat>). Default is `longitude`.
#' @param lat.var Variable of latitude (It should be included in the <dat>). Default is `latitude`.
#' @param remove.na Whether to remove those rows with `NA` in the <dat>? Default is `FALSE`.
#' @param size Text size of labels. Default is `4`.
#' @param digit Digit if the <lab.var> is numeric. Default is `1`.
#' @param hjust Adjust of labels at horizontal direction. Default is `0.5`.
#' @param vjust Adjust of labels at vertical direction. Default is `0.5`.
#' @return A ggplot2 object.
#' @seealso \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' @examples
#' ##### Example 1: a map with polygons named by administrative district names #####
#' # Initialization of the visualizations
#' data(common.map.mean)
#' class(common.map.mean)
#' names(common.map.mean)
#' showtext::showtext_auto(enable = TRUE)
#'
#' # Shows administrative district names in each polygon
#' common.map.mean %>% plot_bmap() %>%
#'     add_label(dat = common.map.mean@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER')
#'
#' # Shows both the administrative district names and sample numbers in each polygon
#' common.map.mean %>% plot_bmap() %>%
#'     add_label(dat = common.map.mean@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER') %>%
#'     add_label(dat = common.map.mean@data, lab.var = 'sample.num', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               lab.col = 'blue', vjust = 3)
#'
#' # Shows both the administrative district names and average Shannon-Wiener diversity index in each polygon
#' common.map.mean %>% plot_bmap() %>%
#'     add_label(dat = common.map.mean@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER') %>%
#'     add_label(dat = common.map.mean@data, lab.var = 'shannon_mean', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               lab.col = 'blue', vjust = 3, digit = 4)
#'
#' # Shows both the administrative district names and average Shannon-Wiener diversity index in each polygon
#' # Meanwhile, the map areas are also filled by colors based on the average Shannon-Wiener diversity index
#' common.map.mean %>% plot_bmap(fill = 'auto', var = 'shannon_mean') %>%
#'     add_label(dat = common.map.mean@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER') %>%
#'     add_label(dat = common.map.mean@data, lab.var = 'shannon_mean', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               lab.col = 'white', vjust = 3, digit = 4)
#'
#' # Shows both the administrative district names and Shannon-Wiener diversity index (mean ± se) in each polygon
#' # Meanwhile, the map areas are also filled by colors based on the average Shannon-Wiener diversity index
#' common.map.mean@data$label.new <- paste0(common.map.mean@data$shannon_mean %>% round(., 3), " ± ",
#'                                          common.map.mean@data$shannon_se %>% round(., 3))
#' common.map.mean %>% plot_bmap(fill = 'auto', var = 'shannon_mean') %>%
#'     add_label(dat = common.map.mean@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER') %>%
#'     add_label(dat = common.map.mean@data, lab.var = 'label.new', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               lab.col = 'white', vjust = 3)
#'
#' ##### Example 2: a map with polygons named by grids #####
#' # Initialization of the visualizations
#' data(gridded.map.mean)
#' class(gridded.map.mean)
#' names(gridded.map.mean)
#' showtext::showtext_auto(enable = TRUE)
#'
#' # Shows all grid names in each grid
#' gridded.map.mean %>% plot_bmap() %>%
#'     add_label(dat = gridded.map.mean@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER')
#'
#' # Shows grid names with sampling sites in each grid
#' gridded.map.mean %>% plot_bmap() %>%
#'     add_label(dat = gridded.map.mean@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               remove.na = TRUE)
#'
#' # Shows sample numbers in each grid
#' gridded.map.mean %>% plot_bmap() %>%
#'     add_label(dat = gridded.map.mean@data, lab.var = 'sample.num', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               remove.na = TRUE)
#'
#' # Shows average Shannon-Wiener diversity index in each grid
#' gridded.map.mean %>% plot_bmap() %>%
#'     add_label(dat = gridded.map.mean@data, lab.var = 'shannon_mean', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               remove.na = TRUE)
#'
#' # Shows average Shannon-Wiener diversity index in each grid
#' # Meanwhile, the map grid are also filled by colors based on the average Shannon-Wiener diversity index
#' gridded.map.mean %>% plot_bmap(fill = 'auto', var = 'shannon_mean') %>%
#'     add_label(dat = gridded.map.mean@data, lab.var = 'shannon_mean', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               remove.na = TRUE)
#'
#' # Shows average Shannon-Wiener diversity index in each grid
#' # Meanwhile, the map grid are also filled by colors based on the standard error of Shannon-Wiener diversity index
#' gridded.map.mean %>% plot_bmap(fill = 'auto', var = 'shannon_se') %>%
#'     add_label(dat = gridded.map.mean@data, lab.var = 'shannon_mean', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               remove.na = TRUE)
#'
#' # Shows average Shannon-Wiener diversity index in each grid
#' # Meanwhile, the map grid are also filled by colors based on sample numbers
#' gridded.map.mean %>% plot_bmap(fill = 'auto', var = 'sample.num') %>%
#'     add_label(dat = gridded.map.mean@data, lab.var = 'shannon_mean', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               remove.na = TRUE)
#'
#' # Shows average Shannon-Wiener diversity index (mean ± se) in each grid
#' # Meanwhile, the map grid are also filled by colors based on the average Shannon-Wiener diversity index
#' gridded.map.mean@data$label.new <- paste0(gridded.map.mean@data$shannon_mean %>% round(., 1), " ± ",
#'                                           gridded.map.mean@data$shannon_se %>% round(., 1))
#' gridded.map.mean %>% plot_bmap(fill = 'auto', var = 'shannon_mean') %>%
#'     add_label(dat = gridded.map.mean@data, lab.var = 'label.new', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               remove.na = TRUE)
#' @export
add_label = function(map.layer, dat, lab.var, lab.col = 'black', lon.var = 'longitude', lat.var = 'latitude',
                     remove.na = FALSE, size = 4, digit = 1, hjust = 0.5, vjust = 0.5){
    map.layer %>% check_ggplot2_object()
    dat %>% check_label_data(., lon.var, lat.var, lab.var)
    map.crs <- terra::crs(ggplot_build(map.layer)$data[[1]]$geometry %>% terra::vect(), proj = TRUE,
                          describe = TRUE, parse = TRUE)[1, 6]
    if (remove.na) dat %<>% na.omit()
    dat.dd <- sf::st_as_sf(dat, coords = c(lon.var, lat.var), crs = map.crs)
    if (dat[,lab.var] %>% is.character | dat[,lab.var] %>% is.factor){
        p.map <- map.layer + geom_sf_text(data = dat.dd, aes(label = .data[[lab.var]]),
                                          size = size, hjust = hjust, vjust = vjust, color = lab.col)
    }
    if (dat[,lab.var] %>% is.numeric){
        p.map <- map.layer + geom_sf_text(data = dat.dd, aes(label = round(.data[[lab.var]], digit)),
                                          size = size, hjust = hjust, vjust = vjust, color = lab.col)
    }
    p.map <- p.map + theme(axis.title = element_blank())
    return(p.map)
}

#' @title Add points on a map
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is desinged to add points on the map based on a numeric vector. The shape of point is fixed
#' as `21`, while the size and color of points could be customized via using the <lab.var> argument for rendering. If you
#' want to visualize sampling sites on geographic maps, please see the document of `microgeo::add_sampl_site()`.
#' @param map.layer A ggplot2 object of geographic map.
#' @param dat A `data.frame` containing the coordinates and the variable to be used for adding points on the map.
#' @param lab.var Variable used for adding points on the map (It should be included in the <dat>).
#' @param lon.var Variable name of longitude (It should be included in the <dat>). Default is `longitude`.
#' @param lat.var Variable name of latitude (It should be included in the <dat>). Default is `latitude`.
#' @param remove.na Whether to remove those rows with `NA` in the <dat>? Default is `FALSE`.
#' @param fill A color value or a color vector for filling the points. If the length of <fill> is 1, we directly use such
#' a color for filling points. If the length of <fill> is greater than 1, then we will render the point by the <lab.var>.
#' Default is `NA`.
#' @param color Color of points. Default is `gray30`.
#' @param alpha Transparency of points. Default is `1`.
#' @param hjust Adjust of labels at horizontal direction. Default is `0.5`.
#' @param vjust Adjust of labels at vertical direction. Default is `0.5`.
#' @return A ggplot2 object.
#' @seealso
#' \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' \code{\link[microgeo:add_label]{microgeo::add_label()}}
#' @examples
#' ##### Example 1: add points on a map with polygons named by grids #####
#' # Initialization of the visualizations
#' data(gridded.map.mean)
#' names(gridded.map.mean)
#' showtext::showtext_auto(enable = TRUE)
#'
#' # The size of points represents the average Shannon-Wiener diversity index
#' gridded.map.mean %>% plot_bmap() %>%
#'     add_point(dat = gridded.map.mean@data, lab.var = 'shannon_mean', lon.var = "X.CENTER", lat.var = "Y.CENTER",
#'               remove.na = TRUE)
#'
#' # The size of points represents the average Shannon-Wiener diversity index
#' # There is only one color, so the color has no real significance
#' gridded.map.mean %>% plot_bmap() %>%
#'     add_point(dat = gridded.map.mean@data, lab.var = 'shannon_mean', lon.var = "X.CENTER", lat.var = "Y.CENTER",
#'               fill = 'lightblue', alpha = 0.5, remove.na = TRUE)
#'
#' # The size and color of points represents the average Shannon-Wiener diversity index
#' gridded.map.mean %>% plot_bmap() %>%
#'     add_point(dat = gridded.map.mean@data, lab.var = 'shannon_mean', lon.var = "X.CENTER", lat.var = "Y.CENTER",
#'               fill = c("green", "red"), alpha = 0.5, remove.na = TRUE)
#' gridded.map.mean %>% plot_bmap() %>%
#'     add_point(dat = gridded.map.mean@data, lab.var = 'shannon_mean', lon.var = "X.CENTER", lat.var = "Y.CENTER",
#'               fill = c("green", "white", "red"), alpha = 0.5, remove.na = TRUE)
#'
#' # The size and color of points represents the average Shannon-Wiener diversity index
#' # The number means the standard error of Shannon-Wiener diversity index
#' gridded.map.mean %>% plot_bmap() %>%
#'     add_point(dat = gridded.map.mean@data, lab.var = 'shannon_mean', lon.var = "X.CENTER", lat.var = "Y.CENTER",
#'               fill = c("green", "white", "red"), alpha = 0.5, remove.na = TRUE) %>%
#'     add_label(dat = gridded.map.mean@data, lab.var = 'shannon_se', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               remove.na = TRUE)
#'
#' # The size and color of points represents the average Shannon-Wiener diversity index
#' # The label means the standard error of Shannon-Wiener diversity index
#' gridded.map.mean@data$new.label <- paste0("±", gridded.map.mean@data$shannon_se %>% round(., 1))
#' gridded.map.mean %>% plot_bmap() %>%
#'     add_point(dat = gridded.map.mean@data, lab.var = 'shannon_mean', lon.var = "X.CENTER", lat.var = "Y.CENTER",
#'               fill = c("green", "white", "red"), alpha = 0.5, remove.na = TRUE) %>%
#'     add_label(dat = gridded.map.mean@data, lab.var = 'new.label', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               remove.na = TRUE)
#'
#' # The color of grids means the average Shannon-Wiener diversity index
#' # The size of points represents the standard error of Shannon-Wiener diversity index
#' # The number means the number of sampling sites in each grid
#' gridded.map.mean %>% plot_bmap(var = 'shannon_mean', fill = 'auto') %>%
#'     add_point(dat = gridded.map.mean@data, lab.var = 'shannon_se', lon.var = "X.CENTER", lat.var = "Y.CENTER",
#'               remove.na = TRUE) %>%
#'     add_label(dat = gridded.map.mean@data, lab.var = 'sample.num', lon.var = 'X.CENTER', lat.var = 'Y.CENTER',
#'               remove.na = FALSE)
#'
#' ##### Example 2: add points on a map with polygons named by administrative district names #####
#' data(qtp)
#' met <- cbind(qtp$met, qtp$env)
#' map <- read_aliyun_map(adcode = c(540000, 630000, 510000))
#' map %>% plot_bmap() %>% add_point(dat = met, lab.var = 'pH')
#' map %>% plot_bmap() %>% add_point(dat = met, lab.var = 'pH', fill = 'lightblue', alpha = 0.5)
#' map %>% plot_bmap() %>% add_point(dat = met, lab.var = 'pH', fill = RColorBrewer::brewer.pal(11, 'RdYlGn'))
#' @export
add_point = function(map.layer, dat, lab.var, lon.var = 'longitude', lat.var = 'latitude', remove.na = FALSE,
                     fill = NA, color = 'gray30', alpha = 0.5, hjust = 0.5, vjust = 0.5){
    map.layer %>% check_ggplot2_object()
    dat %>% check_label_data(., lon.var, lat.var, lab.var, lab.var.must.be.num = TRUE)
    if (remove.na) dat %<>% na.omit()
    map.crs <- terra::crs(ggplot_build(map.layer)$data[[1]]$geometry %>% terra::vect(),
                          proj = TRUE, describe = TRUE, pars = TRUE)[1, 6]
    dat.dd <- sf::st_as_sf(dat, coords = c(lon.var, lat.var), crs = map.crs)
    if (fill %>% is.na %>% any){
        p.map <- map.layer + geom_sf(data = dat.dd, aes(size = .data[[lab.var]]), fill = NA,
                                     color = color, shape = 21, alpha = alpha)
        return(p.map)
    }
    if (fill %>% length == 1){
        p.map <- map.layer +
            geom_sf(data = dat.dd, aes(size = .data[[lab.var]]), fill = fill, color = color,
                    shape = 21, alpha = alpha)
    }else{
        p.map <- map.layer +
            geom_sf(data = dat.dd, aes(size = .data[[lab.var]], fill = .data[[lab.var]]), color = color,
                    shape = 21, alpha = alpha) + scale_fill_gradientn(name = lab.var, colours = fill)
    }
    return(p.map)
}

#' @title Add SpatRaster on a map
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is designed to add a SpatRaster on the map via using the \code{tidyterra::geom_spatraster}.
#' @param map.layer A ggplot2 object of geographic map.
#' @param spat.raster A `SpatRaster` object to be visualized.
#' @param colors A vector of color values, which would be used for SpatRaster visualization. Default is `'auto'`.
#' @param breaks A numeric vector indicating the breaks of legend. If it is `NULL`, then a continuous color bar of legend
#' would be automatically applied. Default is `NULL`.
#' @param labels A character vector indicating the labels of legend break. Only works when breaks is not `NULL`.
#' @param show.border Whether to show map border on the SpatRaster? Default is `TRUE`.
#' @param border.color Color of map border. Default is `black`.
#' @param border.size Width of map border. Default is `1`.
#' @param legend.title The title of legend. Default is `NULL`.
#' @param facet.col.nums Number of facet. Only works when there are more than one layers in SpatRaster. Default is `1`.
#' @param facet.title.size Text size of facet title. It only works when there are more than one layers in SpatRaster. The
#' Default is `15`.
#' @param ... Parameters parsed by \code{tidyterra::geom_spatraster()}.
#' @return A ggplot2 object.
#' @seealso
#' \code{\link[microgeo:read_aliyun_map]{microgeo::read_aliyun_map()}}
#' \code{\link[microgeo:create_dataset]{microgeo::create_dataset()}}
#' \code{\link[microgeo:get_his_bioc]{microgeo::get_his_bioc()}}
#' \code{\link[microgeo:get_fut_bioc]{microgeo::get_fut_bioc()}}
#' \code{\link[microgeo:get_soilgrid]{microgeo::get_soilgrid()}}
#' \code{\link[microgeo:show_dataset]{microgeo::show_dataset()}}
#' \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' \code{\link[microgeo:add_label]{microgeo::add_label()}}
#' @examples
#' # Read the map downloaded from DataV.GeoAtlas, and create a standard dataset
#' data(qtp)
#' showtext::showtext_auto(enable = TRUE)
#' map <- read_aliyun_map(adcode = c(540000, 630000, 510000))
#' dataset.dts  <- create_dataset(mat = qtp$asv, ant = qtp$tax, met = qtp$met, map = map,
#'                                phy = qtp$tre, env = qtp$env, lon = "longitude", lat = "latitude")
#' dataset.dts %<>% get_his_bioc(res = 2.5, out.dir = "test/microgeo_data")
#' dataset.dts %<>% get_fut_bioc(res = 2.5, out.dir = "test/microgeo_data")
#' dataset.dts %<>% get_soilgrid(depth = 5, out.dir = "test/microgeo_data", measures = c('phh2o'))
#' dataset.dts %>% show_dataset()
#'
#' # Add SpatRaster on a map without facets (`soil pH` without legend breaks)
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_spatraster(spat.raster = dataset.dts$spa$rast$his$phh2o) %>%
#'     add_label(dat = dataset.dts$map@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER')
#'
#' # Add SpatRaster on a map without facets (`soil pH` with custom legend breaks)
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_spatraster(spat.raster = dataset.dts$spa$rast$his$phh2o, breaks = c(5.5, 6.5, 7.5, 8.5)) %>%
#'     add_label(dat = dataset.dts$map@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER')
#'
#' # Add SpatRaster on a map without facets (`soil pH` with custom legend breaks and labels)
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_spatraster(spat.raster = dataset.dts$spa$rast$his$phh2o, breaks = c(5,6,7,8),
#'                    labels = c("A", "B", "C", "D", "E")) %>%
#'     add_label(dat = dataset.dts$map@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER')
#'
#' # Add SpatRaster on a map with two facets (`Mean annual temperature` without legend breaks)
#' spatDat <- c(dataset.dts$spa$rast$his$Bio1, dataset.dts$spa$rast$fut$`BCC-CSM2-MR|ssp585|2061-2080`$Bio1)
#' names(spatDat) <- c("Historical", "ssp585|2061-2080")
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_spatraster(spat.raster = spatDat, legend.title = "Bio1", facet.col.nums = 2) %>%
#'     add_label(dat = dataset.dts$map@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER')
#'
#' # Add SpatRaster on a map with two facets (`Mean annual temperature` with custom legend breaks and labels)
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_spatraster(spat.raster = spatDat, breaks = c(-2,-1,1,2), labels = c("A", "B", "C", "D", "E"),
#'                    legend.title = "Bio1", facet.col.nums = 2) %>%
#'     add_label(dat = dataset.dts$map@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER')
#' @export
add_spatraster = function(map.layer, spat.raster, colors = 'auto', breaks = NULL, labels = NULL, show.border = TRUE,
                          border.color = 'black', border.size = 1, legend.title = NULL, facet.col.nums = 1,
                          facet.title.size = 15, ...){
    map.layer %>% check_ggplot2_object(); spat.raster %>% check_spatraster()
    if (any(!is.null(breaks)) && any(!is.null(labels))){ # Check breaks and labels if both of them are not `NULL`
        if (length(labels) != length(breaks) + 1) {
            paste0(breaks %>% length + 1, " labels are required!") %>% stop()
        }
    }
    if (length(colors) == 1 && colors == 'auto') { # Automatically generate colors
        if (terra::is.factor(spat.raster) || any(!is.null(breaks))){
            colors <- RColorBrewer::brewer.pal(11, "RdYlGn")[c(1,3,5,9,11)] %>% rev()
        }else{
            colors <- colorRampPalette(RColorBrewer::brewer.pal(11, "RdYlGn"))(100) %>% rev()
        }
    }
    if (!terra::is.factor(spat.raster) && any(is.null(breaks))){
        if (spat.raster %>% names %>% length == 1) {
            map.layer <- map.layer + tidyterra::geom_spatraster(data = spat.raster) %>% suppressMessages() +
                scale_fill_gradientn(name = ifelse(legend.title %>% is.null, spat.raster %>% names, legend.title),
                                     colours = colors, na.value = "transparent")
        }else{
            map.layer <- map.layer + tidyterra::geom_spatraster(data = spat.raster) %>% suppressMessages() +
                scale_fill_gradientn(name = ifelse(legend.title %>% is.null, spat.raster %>% names, legend.title),
                                     colours = colors, na.value = "transparent") +
                facet_wrap(~lyr, ncol = facet.col.nums)
        }
    }else{
        if (any(!is.null(breaks))){
            label.vals <- ""
            for (i in spat.raster %>% names %>% length %>% seq){
                dat.vals <- terra::values(spat.raster[[i]]) %>%
                    cut(breaks = c(-Inf, breaks, Inf), labels = labels) %>% as.character()
                if (colors %>% length < dat.vals %>% unique %>% na.omit %>% length){
                    dat.vals %>% unique() %>% na.omit() %>% length() %>%
                        paste0(., " discrete colors values are required!") %>% stop()
                }
                terra::values(spat.raster[[i]]) <- dat.vals
                label.vals <- dat.vals %>% na.omit() %>% unique()
            }
            break.val <- label.vals[order(match(label.vals, labels))]
        }
        if (spat.raster %>% names %>% length == 1){
            if ('break.val' %>% exists && !break.val %>% is.null %>% any){
                map.layer <- map.layer + tidyterra::geom_spatraster(data = spat.raster, ...) %>% suppressMessages() +
                    scale_fill_manual(name = ifelse(is.null(legend.title), names(spat.raster), legend.title),
                                      values = colors, na.value = "transparent", breaks = break.val)
            }else{
                map.layer <- map.layer + tidyterra::geom_spatraster(data = spat.raster, ...) %>% suppressMessages() +
                    scale_fill_manual(name = ifelse(is.null(legend.title), names(spat.raster), legend.title),
                                      values = colors, na.value = "transparent")
            }
        }else{
            if ('break.val' %>% exists && any(!is.null(break.val))){
                map.layer <- map.layer + tidyterra::geom_spatraster(data = spat.raster, ...) %>% suppressMessages() +
                    scale_fill_manual(name = ifelse(is.null(legend.title), names(spat.raster), legend.title),
                                      values = colors, na.value = "transparent", breaks = break.val) +
                    facet_wrap(~lyr, ncol = facet.col.nums)
            }else{
                map.layer <- map.layer + tidyterra::geom_spatraster(data = spat.raster, ...) %>% suppressMessages() +
                    scale_fill_manual(name = ifelse(is.null(legend.title), names(spat.raster), legend.title),
                                      values = colors, na.value = "transparent") +
                    facet_wrap(~lyr, ncol = facet.col.nums)
            }
        }
    }
    if (show.border){
        map.layer <- map.layer + geom_sf(data = ggplot_build(map.layer)$data[[1]]$geometry, fill = NA,
                                         color = border.color, size = border.size)
    }
    if (spat.raster %>% names %>% length > 1){
        map.layer <- map.layer + theme(strip.text = element_text(size = facet.title.size))
    }
    return(map.layer)
}

#' @title Add contours on a map
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is implemented to add contours on a map. It can accept any `SpatRaster` as an input.
#' @param map.layer A ggplot2 object of geographic map.
#' @param spat.raster A SpatRaster object to be visualized.
#' @param color Color of contours. Default is `rev(colorRampPalette(RColorBrewer::brewer.pal(11, "RdYlGn"))(100))`.
#' @param nlevels nlevels Default is `10`.
#' @param show.labels Whether to show labels on contours? Default is `FALSE`.
#' @param label.size label.size Default is `4`.
#' @return A ggplot2 object.
#' @seealso
#' \code{\link[microgeo:read_aliyun_map]{microgeo::read_aliyun_map()}}
#' \code{\link[microgeo:create_dataset]{microgeo::create_dataset()}}
#' \code{\link[microgeo:rarefy_count_table]{microgeo::rarefy_count_table()}}
#' \code{\link[microgeo:tidy_dataset]{microgeo::tidy_dataset()}}
#' \code{\link[microgeo:calc_alpha_div]{microgeo::calc_alpha_div()}}
#' \code{\link[microgeo:show_dataset]{microgeo::show_dataset()}}
#' \code{\link[microgeo:interp_kri]{microgeo::interp_kri()}}
#' \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' \code{\link[microgeo:add_spatraster]{microgeo::add_spatraster()}}
#' \code{\link[microgeo:add_label]{microgeo::add_label()}}
#' @examples
#' # Read the map downloaded from DataV.GeoAtlas, and create a standard dataset
#' data(qtp)
#' showtext::showtext_auto(enable = TRUE)
#' map <- read_aliyun_map(adcode = c(540000, 630000, 510000))
#' dataset.dts <- create_dataset(mat = qtp$asv, ant = qtp$tax, met = qtp$met, map = map,
#'                               phy = qtp$tre, env = qtp$env, lon = "longitude", lat = "latitude")
#' dataset.dts %<>% rarefy_count_table()
#' dataset.dts %<>% tidy_dataset()
#' dataset.dts %<>% calc_alpha_div(measures = c("observed", "shannon"))
#' dataset.dts %>% show_dataset()
#'
#' # Perform kriging interpolation for Shannon diversity indices
#' kri.rst <- interp_kri(map = dataset.dts$map, met = dataset.dts$met,
#'                       dat = dataset.dts$div$alpha, var = 'shannon', model = 'Mat', trim.dup = TRUE)
#'
#' # Visualize the interpolated results
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_spatraster(spat.raster = kri.rst) %>%
#'     add_label(dat = dataset.dts$map@data, lab.var = 'NAME', lon.var = "X.CENTER", lat.var = "Y.CENTER")
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_spatraster(spat.raster = kri.rst, show.border = FALSE) %>%
#'     add_contour(spat.raster = kri.rst, color = 'black')
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_spatraster(spat.raster = kri.rst, show.border = FALSE) %>%
#'     add_contour(spat.raster = kri.rst, color = 'black', nlevels = 10, show.labels = TRUE)
#' dataset.dts$map %>% plot_bmap() %>% add_contour(spat.raster = kri.rst, nlevels = 80)
#' dataset.dts$map %>% plot_bmap() %>% add_contour(spat.raster = kri.rst, nlevels = 10, show.labels = TRUE)
#' @export
add_contour = function(map.layer, spat.raster, color = rev(colorRampPalette(RColorBrewer::brewer.pal(11, 'RdYlGn'))(100)),
                       nlevels = 10, show.labels = FALSE, label.size = 4){
    map.layer %>% check_ggplot2_object(); spat.raster %>% check_spatraster()
    contour.lines <- spat.raster %>% terra::as.contour(., nlevels = nlevels)
    sf.contours <- contour.lines %>% sf::st_as_sf()
    if (color %>% length == 1){
        p.map <- map.layer + geom_sf(data = sf.contours, color = color)
    }else{
        p.map <- map.layer +
            geom_sf(data = sf.contours, aes(color = level)) +
            scale_color_gradientn(name = spat.raster %>% names, colours = color)
    }
    if (show.labels) p.map <- p.map +
        geom_sf_text(data = sf.contours, aes(label = level), color = "black", size = label.size)
    p.map <- p.map + theme(axis.title = element_blank())
    return(p.map)
}

#' @title Add north arrow on a map
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is used to add a north arrow on a map using the \code{ggspatial::annotation_north_arrow()}.
#' @param map.layer A ggplot2 object of geographic map.
#' @param position Position of the north arrow. Select one from `'bl', 'br', 'tl', 'tr'`. Default is `tr`.
#' @param which.north The `grid` results in a north arrow always pointing up, while the `true` always points to the north
#' pole from which ever corner of the map the north arrow is in. Default is `'true'`
#' @param height Height of north arrow. Default is `2.5` cm.
#' @param width Width of north arrow. Default is `2.5` cm.
#' @param style Style of north arrow. See \code{ggspatial::north_arrow_orienteering()} for more detailed options. Default
#' is `auto`, which represents the style of `north_arrow_fancy_orienteering` with the following options: `line_width = 1`,
#' `line_col = "black"`, `fill = c("white", "black")`, `text_col = "black"`, `text_family = ""`, `text_face = "bold"`,
#' `text_size = 18`, `text_angle = 0`.
#' @param ... Parameters parsed by \code{ggspatial::annotation_north_arrow()}.
#' @return A ggplot2 object.
#' @seealso
#' \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' \code{\link[ggspatial:north_arrow_fancy_orienteering]{ggspatial::north_arrow_fancy_orienteering()}}
#' \code{\link[ggspatial:annotation_north_arrow]{ggspatial::annotation_north_arrow()}}
#' @examples
#' data(common.map.mean)
#' common.map.mean  %>% plot_bmap()
#' common.map.mean  %>% plot_bmap() %>% add_north_arrow()
#' @export
add_north_arrow = function(map.layer, position = c('bl', 'br', 'tl', 'tr'), which.north = 'true',
                           height = 2.5, width = 2.5, style = 'auto', ...){
    map.layer %>% check_ggplot2_object()
    position <- ifelse(position %>% length > 1, position[length(position)], position)
    if (style == 'auto'){
        style <- ggspatial::north_arrow_fancy_orienteering(line_width = 1, line_col = 'black', fill = c('white', 'black'),
                                                           text_col = 'black', text_family = '', text_face = 'bold',
                                                           text_size = 15, text_angle = 0)
    }
    map.layer <- map.layer +
        ggspatial::annotation_north_arrow(location = position, which_north = which.north,
                                          style = style, height = unit(height, "cm"),
                                          width = unit(width, "cm"), ...)
    return(map.layer)
}

#' @title Add spatial-aware scale bar on a map
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is used to add spatial-aware scale bar on a map using \code{ggspatial::annotation_scale()}.
#' @param map.layer A ggplot2 object of geographic map.
#' @param position Position of spatial-aware scale bar. Select one from `'bl', 'br', 'tl', 'tr'`. Default is `bl`.
#' @param fill Fill color of spatial-aware scale bar. Two color values are required. Default is `c('white', 'black')`.
#' @param size Size of text in spatial-aware scale bar. Default is `1`.
#' @param color Color of text in spatial-aware scale bar. Default is `black`.
#' @param height Height of spatial-aware scale bar. Default is `0.4` cm.
#' @param hint Proportion of the plot area which the spatial-aware scale bar should occupy. Default is `0.4`.
#' @param ... Parameters parsed by \code{ggspatial::annotation_scale()}.
#' @return A ggplot2 object.
#' @seealso
#' \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' \code{\link[microgeo:add_north_arrow]{microgeo::add_north_arrow()}}
#' \code{\link[ggspatial:annotation_scale]{ggspatial::annotation_scale()}}
#' @examples
#' data(common.map.mean)
#' common.map.mean  %>% plot_bmap()
#' common.map.mean  %>% plot_bmap() %>% add_north_arrow()
#' common.map.mean  %>% plot_bmap() %>% add_north_arrow() %>% add_scale_bar()
#' @export
add_scale_bar = function(map.layer, position = c('bl', 'br', 'tl', 'tr'), fill = c('white', 'black'), size = 1,
                         color = 'black', height = 0.4, hint = 0.5, ...){
    map.layer %>% check_ggplot2_object()
    position <- ifelse(position %>% length > 1, position[1], position)
    if (fill %>% length < 2) paste0("Two color values are required for <fill>!") %>% stop()
    map.layer <- map.layer +
        ggspatial::annotation_scale(location = position, bar_cols = fill[1:2],text_cex = size, text_col = color,
                                    text_face = 'bold', height = unit(height, "cm"), width_hint = hint, ...)
    return(map.layer)
}

#' @title Add coordinate reference system to a map before the final visualization
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is designed to add coordinate reference system to a map before final visualizations through
#' using the \code{ggplot2::coord_sf()}.
#' @param map.layer A ggplot2 object of geographic map.
#' @param crs Coordinate reference system (CRS) into which all data should be projected before plotting. If it is `NULL`,
#' we will use the CRS defined in the first `sf` layer of the plot. Default is `+proj=laea +lat_0=40 +lon_0=104`.
#' @param expand If `TRUE`, we will add a small expansion factor to the limits to ensure that data and axes don't overlap.
#' If `FALSE`, limits are taken exactly from the data or xlim/ylim. Default is `TRUE`.
#' @param ... Parameters parsed by \code{ggplot2::coord_sf()}.
#' @return A ggplot2 object.
#' @seealso
#' \code{\link[ggplot2:coord_sf]{ggplot2::coord_sf()}}
#' \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' \code{\link[microgeo:add_scale_bar]{microgeo::add_scale_bar()}}
#' \code{\link[microgeo:add_north_arrow]{microgeo::add_north_arrow()}}
#' @examples
#' data(common.map.mean)
#' common.map.mean  %>% plot_bmap()
#' common.map.mean  %>% plot_bmap() %>% add_north_arrow()
#' common.map.mean  %>% plot_bmap() %>% add_north_arrow() %>% add_scale_bar()
#' common.map.mean  %>% plot_bmap() %>% add_north_arrow() %>% add_scale_bar() %>% add_crs()
#' common.map.mean  %>% plot_bmap() %>% add_north_arrow() %>% add_scale_bar() %>% add_crs(expand = FALSE)
#' @export
add_crs = function(map.layer, crs = "+proj=laea +lat_0=40 +lon_0=104", expand = TRUE, ...){
    map.layer %>% check_ggplot2_object()
    if (!crs %>%is.null){
        map.layer <- map.layer + coord_sf(crs = crs, expand = expand, ...)
    }else{
        map.layer <- map.layer + coord_sf(expand = expand, ...)
    }
    return(map.layer)
}

#' @title Add sampling sites on a map
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is designed to add sampling sites on a map by using the \code{ggplot2::geom_sf()} function.
#' @param map.layer A ggplot2 object of geographic map.
#' @param met  A `data.frame` of sample information. Row names must be sample ids, and the column names are observed
#' variables (e.g., `longitude`, `latitude` and `group`). Longitude and latitude must be included in this dataframe since
#' we primarily focus on the spatial patterns of microbial traits.
#' @param color.var Variable in the <met> used for the color of points. Default is `NULL`.
#' @param color.ord Display order of group names rendered by colors. Default is `NULL`.
#' @param shape.var Variable in the <met> used for the shape of points. Default is `NULL`.
#' @param shape.ord Display order of group names rendered by shapes. Default is `NULL`.
#' @param color.val Border (for all shape codes) or fill color (for the shape code less than 21) values of point. Default
#' is `RColorBrewer::brewer.pal(9, "Set1")`.
#' @param fill.val The fill color of point. This argument only works when all shape codes greater than 20. The Default is
#' `RColorBrewer::brewer.pal(9, "Set1")`.
#' @param shape.val Shape values of point. Default is `c(21, 22, 23, 24)`.
#' @param point.size Size of point. Default is `3`.
#' @param point.alpha Transparency of point. Default is `0.7`.
#' @param facet.by.color Whether to facet the graph by color variable? Default is `FALSE`.
#' @param facet.by.shape Whether to facet the graph by shape variable? Default is `FALSE`.
#' @param facet.col.nums Number of facets. Default is `1`.
#' @param facet.title.size Text size of facet title. Default is `15`.
#' @return A ggplot2 object.
#' @seealso
#' \code{\link[microgeo:read_aliyun_map]{microgeo::read_aliyun_map()}}
#' \code{\link[microgeo:create_dataset]{microgeo::create_dataset()}}
#' \code{\link[microgeo:get_ai]{microgeo::get_ai()}}
#' \code{\link[microgeo:get_his_bioc]{microgeo::get_his_bioc()}}
#' \code{\link[microgeo:get_soilgrid]{microgeo::get_soilgrid()}}
#' \code{\link[microgeo:extract_data_from_spatraster]{microgeo::extract_data_from_spatraster()}}
#' \code{\link[microgeo:tidy_dataset]{microgeo::tidy_dataset()}}
#' \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' \code{\link[microgeo:add_scale_bar]{microgeo::add_scale_bar()}}
#' \code{\link[microgeo:add_north_arrow]{microgeo::add_north_arrow()}}
#' \code{\link[microgeo:add_crs]{microgeo::add_crs()}}
#' \code{\link[microgeo:add_spatraster]{microgeo::add_spatraster()}}
#' @examples
#' # Read the map downloaded from DataV.GeoAtlas, and create a standard dataset
#' data(qtp)
#' map <- read_aliyun_map(adcode = c(540000, 630000, 510000))
#' dataset.dts  <- create_dataset(mat = qtp$asv, ant = qtp$tax, met = qtp$met, map = map,
#'                                phy = qtp$tre, env = qtp$env, lon = "longitude", lat = "latitude")
#' dataset.dts %<>% get_ai(out.dir = "test/microgeo_data")
#' dataset.dts %<>% get_his_bioc(res = 10, out.dir = "test/microgeo_data")
#' dataset.dts %<>% get_soilgrid(out.dir = "test/microgeo_data")
#' dataset.dts %<>% extract_data_from_spatraster(type = 'his')
#' dataset.dts %<>% tidy_dataset()
#' dataset.dts$met$aridity.region <- cut(dataset.dts$spa$tabs$AI, breaks = c(-Inf, 0.2, 0.5, Inf),
#'                                       labels = c("H", "A", "S"))
#' dataset.dts$met$mat.region <- cut(dataset.dts$spa$tabs$Bio1, breaks = c(-Inf, -1, 1, Inf),
#'                                   labels = c("LT", "MT", "HT"))
#'
#' # Plot a basic map with sampling sites
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_sampl_site(met = dataset.dts$met, color.val = "gray30", fill.val = "white", point.alpha = 0.5) %>%
#'     add_scale_bar() %>% add_north_arrow() %>% add_crs()
#'
#' # Plot a basic map with sampling sites, and add the colors
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_sampl_site(met = dataset.dts$met, color.var = "aridity.region", color.val = "gray30", point.alpha = 0.5) %>%
#'     add_scale_bar() %>% add_north_arrow() %>% add_crs()
#'
#' # Plot a basic map with sampling sites, and add the colors/shapes
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_sampl_site(met = dataset.dts$met, color.var = "aridity.region", shape.var = "aridity.region",
#'                    color.val = "gray30", point.alpha = 0.5) %>%
#'     add_scale_bar() %>% add_north_arrow() %>% add_crs()
#'
#' # Plot a basic map, and add the colors/shapes/facet
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_sampl_site(met = dataset.dts$met, color.var = "aridity.region", shape.var = "aridity.region",
#'                    color.val = "gray30", point.alpha = 0.5, facet.by.color = T, facet.col.nums = 1) %>%
#'     add_scale_bar() %>% add_north_arrow() %>% add_crs()
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_sampl_site(met = dataset.dts$met, color.var = "aridity.region", shape.var = "mat.region",
#'                    color.val = "gray30", point.alpha = 0.5, facet.by.color = T, facet.by.shape = T) %>%
#'     add_scale_bar() %>% add_north_arrow() %>% add_crs()
#'
#' # Plot a basic map, and add the colors/shapes/facet/SpatRaster
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_spatraster(spat.raster = dataset.dts$spa$rast$his$phh2o) %>%
#'     add_sampl_site(met = dataset.dts$met, color.var = "aridity.region", shape.var = "aridity.region",
#'                    color.val = "gray30", point.alpha = 0.5, facet.by.color = T, facet.col.nums = 1) %>%
#'     add_scale_bar() %>% add_north_arrow() %>% add_crs()
#' dataset.dts$map %>% plot_bmap() %>%
#'     add_spatraster(spat.raster = dataset.dts$spa$rast$his$phh2o) %>%
#'     add_sampl_site(met = dataset.dts$met, color.var = "aridity.region", shape.var = "mat.region",
#'                    color.val = "gray30", point.alpha = 0.5, facet.by.color = T, facet.by.shape = T) %>%
#'     add_scale_bar() %>% add_north_arrow() %>% add_crs()
#' @export
add_sampl_site = function(map.layer, met, color.var = NULL, color.ord = NULL, shape.var = NULL, shape.ord = NULL,
                          color.val = RColorBrewer::brewer.pal(9, "Set1"), fill.val = RColorBrewer::brewer.pal(9, "Set1"),
                          shape.val = c(21, 22, 23, 24), point.size = 3, point.alpha = 0.7, facet.by.color = FALSE,
                          facet.by.shape = FALSE, facet.col.nums = 1, facet.title.size = 15){

    # Initialization of the visualizations
    map.layer %>% check_ggplot2_object()
    met %>% check_metdata(lon = "longitude", lat = "latitude")
    map.crs <- terra::crs(terra::vect(ggplot_build(map.layer)$data[[1]]$geometry),
                          proj=TRUE, describe=TRUE, parse=TRUE)[1, 6]

    # Plot map: if both the <color.var> and <shape.var> are NULL
    if (color.var %>% is.null & shape.var %>% is.null){
        met.cor <- sf::st_as_sf(met, coords = c("longitude", "latitude"), crs = map.crs)
        if (shape.val[1] > 20){ # The shape code more than 20, we can use both color and fill
            p.map <- map.layer + geom_sf(data = met.cor, fill = fill.val[1], color = color.val[1], shape = shape.val[1],
                                         size = point.size, alpha = point.alpha)
        }else{ # We only can use color
            p.map <- map.layer + geom_sf(data = met.cor, color = color.val[1], shape = shape.val[1], size = point.size,
                                         alpha = point.alpha)
        }
    }

    # Plot map: if the <color.var> is not NULL but the <shape.var> is NULL ==> only classifying sampling sites by color
    if (!color.var %>% is.null & shape.var %>% is.null){
        if (!color.var %in% colnames(met)) paste0("The `", color.var, "` do not exist in your met!") %>% stop()
        met$color.group <- met[,color.var]
        if (!color.ord %>% is.null %>% any) met$color.group <- factor(met$color.group, levels = color.ord)
        met.cor <- sf::st_as_sf(met, coords = c("longitude", "latitude"), crs = map.crs)
        if (shape.val[1] > 20){ # The shape code more than 20 ==> use fill color to classify the sampling sites
            if (met$color.group %>% unique %>% length > fill.val %>% length){
                paste0(fill.val %>% length, " fill color values are required!") %>% stop()
            }
            p.map <- map.layer +
                ggnewscale::new_scale_fill() +
                geom_sf(data = met.cor, aes(fill = color.group), color = color.val[1],
                        shape = shape.val[1], size = point.size, alpha = point.alpha) +
                scale_fill_manual(name = color.var, values = fill.val)
        }else{ # The shape code less than or equal to 20 ==> use border color to classify the sampling sites
            if (met$color.group %>% unique %>% length > color.val %>% length){
                paste0(color.val %>% length, " color values are required!") %>% stop()
            }
            p.map <- map.layer +
                ggnewscale::new_scale_color() +
                geom_sf(data = met.cor, aes(color = color.group), shape = shape.val[1],
                        size = point.size, alpha = point.alpha) +
                scale_color_manual(name = color.var, values = color.val)
        }
        if (facet.by.color){
            p.map <- p.map +
                facet_wrap(~color.group, ncol = facet.col.nums) +
                theme(strip.text = element_text(size = facet.title.size))
        }
    }

    # Plot map: if the <color.var> is NULL but the <shape.var> is not NULL ==> only classifying sampling sites by shape
    if (color.var %>% is.null & !shape.var %>% is.null){
        if (!shape.var %in% colnames(met)) paste0("The `", shape.var, "` do not exist in your met!") %>% stop()
        met$shape.group <- met[,shape.var]
        if (!shape.ord %>% is.null %>% any) met$shape.group <- factor(met$shape.group, levels = shape.ord)
        if (met$shape.group %>% unique %>% length > shape.val %>% length){
            paste0(shape.val %>% length, " shape values are required!") %>% stop()
        }
        met.cor <- sf::st_as_sf(met, coords = c("longitude", "latitude"), crs = map.crs)
        if (TRUE %in% unique(shape.val < 21)){ # There are shape code less than 21, so we can not apply the fill color
            p.map <- map.layer +
                geom_sf(data = met.cor, aes(shape = shape.group),
                        color = color.val[1], size = point.size, alpha = point.alpha) +
                scale_shape_manual(name = shape.var, values = shape.val)
        }else{ # We can use both fill and color here
            p.map <- map.layer +
                geom_sf(data = met.cor, aes(shape = shape.group), fill = fill.val[1], color = color.val[1],
                        size = point.size, alpha = point.alpha) +
                scale_shape_manual(name = shape.var, values = shape.val)
        }
        if (facet.by.shape){
            p.map <- p.map +
                facet_wrap(~shape.group, ncol = facet.col.nums) +
                theme(strip.text = element_text(size = facet.title.size))
        }
    }

    # Plot map: if the <color.var> and <shape.var> are not NULL ==> classifying sampling sites by both color and shape
    if (!color.var %>% is.null & !shape.var %>% is.null){
        if (!color.var %in% colnames(met)) paste0("The `", color.var, "` do not exist in your met!") %>% stop()
        if (!shape.var %in% colnames(met)) paste0("The `", shape.var, "` do not exist in your met!") %>% stop()
        met$color.group <- met[,color.var]; met$shape.group <- met[,shape.var]
        if (!color.ord %>% is.null %>% any) met$color.group <- factor(met$color.group, levels = color.ord)
        if (!shape.ord %>% is.null %>% any) met$shape.group <- factor(met$shape.group, levels = shape.ord)
        met.cor <- sf::st_as_sf(met, coords = c("longitude", "latitude"), crs = map.crs)
        if (TRUE %in% unique(shape.val < 21)){ # There are shape code less than 21, so we can not apply the fill color
            if (met$color.group %>% unique %>% length > color.val %>% length){
                paste0(color.val %>% length, " color values are required!") %>% stop()
            }
            p.map <- map.layer +
                ggnewscale::new_scale_color() +
                geom_sf(data = met.cor, aes(color = color.group, shape = shape.group),
                        size = point.size, alpha = point.alpha) +
                scale_color_manual(name = color.var, values = color.val) +
                scale_shape_manual(name = shape.var, values = shape.val)
        }else{ # We can use both fill and color here
            if (met$color.group %>% unique %>% length > fill.val %>% length){
                paste0(fill.val %>% length, " fill color values are required!") %>% stop()
            }
            p.map <- map.layer +
                ggnewscale::new_scale_fill() +
                geom_sf(data = met.cor, aes(fill = color.group, shape = shape.group), color = color.val[1],
                        size = point.size, alpha = point.alpha) +
                scale_fill_manual(name = color.var, values = fill.val) +
                scale_shape_manual(name = shape.var, values = shape.val)
        }
        if (facet.by.color & !facet.by.shape){
            p.map <- p.map +
                facet_wrap(~color.group, ncol = facet.col.nums) +
                theme(strip.text = element_text(size = facet.title.size))
        }
        if (!facet.by.color & facet.by.shape){
            p.map <- p.map +
                facet_wrap(~shape.group, ncol = facet.col.nums) +
                theme(strip.text = element_text(size = facet.title.size))
        }
        if (facet.by.color & facet.by.shape){
            if (color.var == shape.var) {
                stop("The <color.var> and <shape.var> should not be same if both the <facet.by.color> and
                     <facet.by.shape> are TRUE!")
            }
            p.map <- p.map +
                facet_grid(color.group ~ shape.group) +
                theme(strip.text = element_text(size = facet.title.size))
        }
    }
    return(p.map)
}
