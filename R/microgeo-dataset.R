# -----------------------------------------------------------------------------------------------------------------------
# Copyright (c) 2023, microgeo/Chaonan Li (licn@mtc.edu.cn).                                                            #
# The microgeo is distributed under the terms of the GPL-3 License.                                                     #
# Full license is avaliable in the file LICENSE, distributed with this package.                                         #
# -----------------------------------------------------------------------------------------------------------------------

#' @title Create a standard microgeo dataset for biogeographic analysis
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function wraps the methods for dataset preparation. It requires several microbiome dataset including
#' ASV (also referred to as OTU in QIIME 1) or gene abundance table (e.g., gene abundance tables generated by metagenomic
#' sequencing, gene chip or high-throughput qPCR techniques), taxonomic/functional annotation tables, metadata containing
#' the coordinates of sampling site (longitude & latitude; required) and other information such as the grouping schema of
#' sampling site, phylogenetic tree of ASVs, and measured environmental properties like `pH` and `TOC`. In addition, this
#' function also requires a `SpatialPolygonsDataFrame` of map because we mainly focus on the spatial pattern of microbial
#' traits. Phylogenetic tree and measured environmental properties are optional.
#' @param mat A `data.frame` of ASV/gene abundances. Row names must be ASV/gene ids and the column names should be sample
#' ids. To avoid unexpected errors, sample ids and ASV/gene ids should not be start with a number. The same below.
#' @param ant A `data.frame` of ASV/gene annotations. Rows names must be ASV/gene ids and the column names are annotation
#' levels (e.g., `Kingdom`, `Phylum`, `Class`, `Order`, `Family`, `Genus`, `Species` for ASV table; `Level 1`, `Level 2`,
#' `Level 3`, `Level 4` for gene abundance table).
#' @param met A `data.frame` of sample information. Row names should be sample ids and the column names must be variables
#' (e.g., `longitude`, `latitude` and `group`). Longitude and latitude must be included in this `data.frame` as we mainly
#' focus on the spatial patterns of microbial traits.
#' @param map A microgeo-compatible `SpatialPolygonsDataFrame` of map. See \code{microgeo::trans_map_fmt()} for details.
#' @param phy An optional phylogenetic tree with a `newick` format (`phylo` class). Required for calculating phylogenetic
#' traits. Default is `NULL`.
#' @param env An optional `data.frame` of measured environmental properties (e.g., `pH` and `TOC`). The row names must be
#' sample ids and the column names should be measured variables. Default is `NULL`.
#' @param lon Column name of longitude in `met`. Default is `longitude`.
#' @param lat Column name of latitude in `met`. Default is `latitude`.
#' @return A `MicrogeoDataset` class with the following components:
#' \describe{
#'   \item{\code{object$mat}}{A `data.frame` of ASV/gene abundance.}
#'   \item{\code{object$ant}}{A `data.frame` of ASV/gene anootations.}
#'   \item{\code{object$met}}{A `data.frame` of sample information.}
#'   \item{\code{object$map}}{A `SpatialPolygonsDataFrame` of map.}
#'   \item{\code{object$phy}}{A phylogenetic tree with `newick` format (`phylo` class) if applicable.}
#'   \item{\code{object$env}}{A `data.frame` of measured environmental properties if applicable.}
#' }
#' @seealso
#' \code{\link[microgeo:read_aliyun_map]{microgeo::read_aliyun_map()}}
#' \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' \code{\link[microgeo:add_label]{microgeo::add_label()}}
#' \code{\link[microgeo:add_scale_bar]{microgeo::add_scale_bar()}}
#' \code{\link[microgeo:add_north_arrow]{microgeo::add_north_arrow()}}
#' \code{\link[microgeo:add_crs]{microgeo::add_crs()}}
#' \code{\link[microgeo:show_dataset]{microgeo::show_dataset()}}
#' @examples
#' # Read a map from the DataV.GeoAtlas
#' showtext::showtext_auto(enable = TRUE)
#' map <- read_aliyun_map(adcode = c(540000, 630000, 510000))
#' map %>% plot_bmap() %>% add_label(dat = map@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER') %>%
#'     add_scale_bar() %>% add_north_arrow() %>% add_crs()
#'
#' # Create a microgeo dataset using bacterial data and the map retrieved from the DataV.GeoAtlas
#' data(qtp)
#' dataset.dts <- create_dataset(mat = qtp$asv, ant = qtp$tax, met = qtp$met, map = map,
#'                               phy = qtp$tre, env = qtp$env, lon = "longitude", lat = "latitude")
#' dataset.dts %>% show_dataset()
#' @export
create_dataset = function(mat, ant, met, map, phy = NULL, env = NULL, lon = 'longitude', lat = 'latitude'){
    if (mat %>% class != "data.frame") stop("The <mat> must be a data.frame!")
    if (ant %>% class != "data.frame") stop("The <ant> must be a data.frame!")
    if (!phy %>% is.null & phy %>% class != "phylo") stop("The <phy> must be a phylo object!")
    if (!env %>% is.null & env %>% class != "data.frame") stop("The <env> must be a data.frame!")
    map %>% check_mapdata(); met %>% check_metdata(lon = lon, lat = lat)
    colnames(met)[which(met %>% colnames == lon)] <- 'longitude'
    colnames(met)[which(met %>% colnames == lat)] <- 'latitude'
    chk.rst <- check_map_area(map = map, met = met, lon = 'longitude', lat = 'latitude')
    if (chk.rst %>% nrow > 0) warning('you can use `check_map_area()` to show these samples.')
    microdata <- list(mat = mat, ant = ant, met = met, map = map, phy = phy, env = env)
    class(microdata) <- append(microdata %>% class, "MicrogeoDataset")
    "dataset has been created successfully!" %>% show_comm_msg()
    "use `object %>% show_dataset()` to check the summary of dataset." %>% show_comm_msg()
    return(microdata)
}

#' @title Check the map area
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is designed to check whether all sampling sites fall within the map area.
#' @param map A microgeo-compatible `SpatialPolygonsDataFrame` of map. See \code{microgeo::trans_map_fmt()} for details.
#' @param met A `data.frame` of sample information. Row names should be sample ids and the column names must be variables
#' (e.g., `longitude`, `latitude` and `group`). Longitude and latitude must be included in this `data.frame` as we mainly
#' focus on the spatial patterns of microbial traits.
#' @param lon Column name of longitude in `met`. Default is `longitude`.
#' @param lat Column name of latitude in `met`. Default is `latitude`.
#' @return A `data.frame` of the coordinates for sampling sites exceeded the map area.
#' @seealso
#' \code{\link[microgeo:read_aliyun_map]{microgeo::read_aliyun_map()}}
#' \code{\link[microgeo:read_shp_map]{microgeo::read_shp_map()}}
#' \code{\link[microgeo:trans_map_fmt]{microgeo::trans_map_fmt()}}
#' \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' \code{\link[microgeo:add_sampl_site]{microgeo::add_sampl_site()}}
#' \code{\link[microgeo:add_scale_bar]{microgeo::add_scale_bar()}}
#' \code{\link[microgeo:add_north_arrow]{microgeo::add_north_arrow()}}
#' \code{\link[microgeo:add_crs]{microgeo::add_crs()}}
#' @examples
#' ##### Example 1: a map downloaded from the DataV.GeoAtlas ####
#' data(qtp)
#' map <- read_aliyun_map(adcode = c(540000, 630000, 510000))
#' rst <- map %>% check_map_area(met = qtp$met, lon = 'longitude', lat = 'latitude')
#' nrow(rst) # it is expected to be 0
#'
#' ##### Example 2: a map loaded from a local ESRI Shapefile (QTP) ####
#' map <- system.file("shapefiles/qtp-map", "DBATP_Polygon.shp", package = "microgeo") %>% read_shp_map()
#' map@data$NAME <- "Qinghai-Tibet Plateau" # Add a column to meet the demands of microgeo::trans_map_fmt()
#' map %<>% trans_map_fmt(var = 'NAME')
#' rst <- map %>% check_map_area(met = qtp$met, lon = 'longitude', lat = 'latitude')
#' nrow(rst) # it is expected to be 3
#' map %>% plot_bmap() %>% add_sampl_site(met = rst) %>%
#'     add_scale_bar() %>% add_north_arrow() %>% add_crs() # Plot a map to show the location of these samples on map
#' # Three samples locate on the boundary of map
#' # Thus, we can ignore the warnings during creating microgeo dataset, if we use the current map.
#' @export
check_map_area = function(map, met, lon = 'longitude', lat = 'latitude'){
    map %>% check_mapdata(); met %>% check_metdata(lon = lon, lat = lat)
    colnames(met)[which(met %>% colnames == lon)] <- 'longitude'
    colnames(met)[which(met %>% colnames == lat)] <- 'latitude'
    check.rst <- met; check.rst$in.map.area <- 0
    mapgeo <- map %>% sf::st_as_sf() %>% sf::st_geometry()
    for (i in mapgeo %>% length %>% seq){
        mapgeo.make.valid <- mapgeo[[i]] %>% sf::st_make_valid()
        test.rst <- lapply(X = met %>% nrow %>% seq, function(x){
            point <- c(met$longitude[x], met$latitude[x]) %>% sf::st_point()
            is_within <- sf::st_within(point, mapgeo.make.valid)
            ifelse(is_within[[1]] %>% length == 0, 0, 1)
        }) %>% unlist()
        check.rst$in.map.area <- check.rst$in.map.area + test.rst
    }
    res <- check.rst[which(check.rst$in.map.area == 0), c('longitude', 'latitude')]
    if (res %>% nrow == 0){
        'all samples fall within the map area!' %>% show_comm_msg()
    }else{
        paste0('there are ', res %>% nrow, ' out of ', met %>% nrow,
            ' samples exceed the range of map area, please delete them or use a suitable map!') %>% warning()
    }
    return(res)
}

#' @title Rarefy ASV or gene count table based on a sub-sample depth
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function wraps \code{vegan::rrarefy()} to rarefy ASV/gene count table. Please note that the sampling
#' depth should not be greater than the min. of sequences in all samples.
#' @param dataset A microgeo dataset with the class of `MicrogeoDataset`.
#' @param depth The depth for rarefaction. If it is `NULL`, the count table would be rarefied based on the min. number of
#' sequence in all samples. Default is `NULL`.
#' @return A `MicrogeoDataset` class with the following components:
#' \describe{
#'   \item{\code{object$mat}}{A `data.frame` of rarefied ASV/gene abundance.}
#'   \item{\code{object$ant}}{A `data.frame` of ASV/gene anootations.}
#'   \item{\code{object$met}}{A `data.frame` of sample information.}
#'   \item{\code{object$map}}{A `SpatialPolygonsDataFrame` of map.}
#'   \item{\code{object$phy}}{A phylogenetic tree with `newick` format (`phylo` class) if applicable.}
#'   \item{\code{object$env}}{A `data.frame` of measured environmental properties if applicable.}
#'   \item{\code{object$*}}{Spatial and biogeographic traits if applicable.}
#' }
#' @seealso
#' \code{\link[vegan:rrarefy]{vegan::rrarefy()}}
#' \code{\link[microgeo:read_aliyun_map]{microgeo::read_aliyun_map()}}
#' \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' \code{\link[microgeo:add_label]{microgeo::add_label()}}
#' \code{\link[microgeo:add_scale_bar]{microgeo::add_scale_bar()}}
#' \code{\link[microgeo:add_north_arrow]{microgeo::add_north_arrow()}}
#' \code{\link[microgeo:add_crs]{microgeo::add_crs()}}
#' \code{\link[microgeo:create_dataset]{microgeo::create_dataset()}}
#' \code{\link[microgeo:show_dataset]{microgeo::show_dataset()}}
#' @examples
#' data(qtp)
#' map <- read_aliyun_map(adcode = c(540000, 630000, 510000))
#' map %>% plot_bmap() %>% add_label(dat = map@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER') %>%
#'     add_scale_bar() %>% add_north_arrow() %>% add_crs()
#' dataset.dts <- create_dataset(mat = qtp$asv, ant = qtp$tax, met = qtp$met, map = map,
#'                               phy = qtp$tre, env = qtp$env, lon = "longitude", lat = "latitude")
#' dataset.dts %>% show_dataset()
#' dataset.dts %<>% rarefy_count_table()
#' dataset.dts %>% show_dataset()
#' @export
rarefy_count_table = function(dataset, depth = NULL){
    dataset %>% check_dataset(); mat.dat <- dataset$mat
    min.seq.num <- mat.dat %>% colSums() %>% min()
    if (depth %>% is.null) depth <- min.seq.num
    #if (depth > min.seq.num) paste0("The <depth> must be less than or equal to ", min.seq.num, "!") %>% stop()
    rarefy.res <- dataset$mat %>% t() %>% vegan::rrarefy(., depth) %>% suppressWarnings() %>% t()
    rarefy.res <- rarefy.res[,colSums(rarefy.res) >= depth]
    paste0("the ASV/gene abundance table has been rarefied with a sub-sample depth of ", depth) %>% show_comm_msg()
    rarefy.res  <- rarefy.res[rarefy.res %>% apply(., 1, sum) > 0,]
    rarefy.res  <- rarefy.res[,rarefy.res %>% apply(., 2, sum) > 0]
    dataset$mat <- rarefy.res
    return(dataset)
}

#' @title Tidy up a microgeo dataset to ensure the valid order of sample and ASV/gene ids
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is designed to tidy up a dataset, which ensures the valid order of sample and ASV/gene ids.
#' When unsure of the dataset's ID order, always use this function.
#' @param dataset A microgeo dataset with the class of `MicrogeoDataset`.
#' @return A `MicrogeoDataset` class with the following components:
#' \describe{
#'   \item{\code{object$mat}}{A `data.frame` of ASV/gene abundance.}
#'   \item{\code{object$ant}}{A `data.frame` of ASV/gene anootations.}
#'   \item{\code{object$met}}{A `data.frame` of sample information.}
#'   \item{\code{object$map}}{A `SpatialPolygonsDataFrame` of map.}
#'   \item{\code{object$phy}}{A phylogenetic tree with `newick` format (`phylo` class) if applicable.}
#'   \item{\code{object$env}}{A `data.frame` of measured environmental properties if applicable.}
#'   \item{\code{object$*}}{Spatial and biogeographic traits if applicable.}
#' }
#' @seealso
#' \code{\link[microgeo:read_aliyun_map]{microgeo::read_aliyun_map()}}
#' \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' \code{\link[microgeo:add_label]{microgeo::add_label()}}
#' \code{\link[microgeo:add_scale_bar]{microgeo::add_scale_bar()}}
#' \code{\link[microgeo:add_north_arrow]{microgeo::add_north_arrow()}}
#' \code{\link[microgeo:add_crs]{microgeo::add_crs()}}
#' \code{\link[microgeo:create_dataset]{microgeo::create_dataset()}}
#' \code{\link[microgeo:show_dataset]{microgeo::show_dataset()}}
#' \code{\link[ape:is.rooted]{ape::is.rooted()}}
#' \code{\link[ape:multi2di]{ape::multi2di()}}
#' \code{\link[ape:drop.tip]{ape::drop.tip()}}
#' @examples
#' data(qtp)
#' map <- read_aliyun_map(adcode = c(540000, 630000, 510000))
#' map %>% plot_bmap() %>%
#'     add_label(dat = map@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER') %>%
#'     add_scale_bar() %>% add_north_arrow() %>% add_crs()
#' dataset.dts <- create_dataset(mat = qtp$asv, ant = qtp$tax, met = qtp$met, map = map,
#'                               phy = qtp$tre, env = qtp$env, lon = "longitude", lat = "latitude")
#' dataset.dts %<>% tidy_dataset()
#' dataset.dts %>% show_dataset()
#' unique(rownames(dataset.dts$mat) == rownames(dataset.dts$ant)) # return `TRUE`
#' unique(colnames(dataset.dts$mat) == rownames(dataset.dts$met)) # return `TRUE`
#' unique(colnames(dataset.dts$mat) == rownames(dataset.dts$env)) # return `TRUE`
#' @export
tidy_dataset = function(dataset){

    # ASV/gene abundance table
    dataset %>% check_dataset()
    if (!dataset$spa$tabs %>% is.null){
        if (!dataset$env %>% is.null){
            sam.ord <- Reduce(intersect,
                              list(dataset$mat %>% colnames, dataset$met %>% rownames,
                                   dataset$env %>% rownames, dataset$spa$tabs %>% rownames))
        }else{
            sam.ord <- Reduce(intersect,
                              list(dataset$mat %>% colnames, dataset$met %>% rownames,
                                   dataset$spa$tabs %>% rownames))
        }
    }else{
        if (!dataset$env %>% is.null){
            sam.ord <- Reduce(intersect,
                              list(dataset$mat %>% colnames, dataset$met %>% rownames,
                                   dataset$env %>% rownames))
        }else{
            sam.ord <- Reduce(intersect,
                              list(dataset$mat %>% colnames, dataset$met %>% rownames))
        }
    }
    mat.dat <- dataset$mat
    mat.idx <- sapply(sam.ord, function(x){ which(mat.dat %>% colnames == x) })
    mat.dat <- mat.dat[, mat.idx] %>% as.data.frame()
    if (unique(mat.dat %>% colnames == sam.ord) %>% length > 1 ||
        !unique(mat.dat %>% colnames == sam.ord)) stop("Failed to sort sample ids in <mat>!")
    mat.dat <- mat.dat[apply(mat.dat, 1, sum) > 0,]; dataset$mat <- mat.dat

    # Annotation table
    ant.ord <- dataset$mat %>% rownames(); ant.dat <- dataset$ant
    ant.idx <- sapply(ant.ord, function(x){ which(ant.dat %>% rownames == x) })
    ant.dat <- ant.dat[ant.idx, ] %>% as.data.frame()
    if (unique(ant.dat %>% rownames == ant.ord) %>% length > 1 ||
        !unique(ant.dat %>% rownames == ant.ord)) stop("Failed to sort ASV/gene ids in <ant>!")
    ant.dat[] <- lapply(ant.dat %>% ncol %>% seq_len, function(x){
        ant.dat[, x] <- ant.dat[, x] %>% gsub("^.*__ ", "", .)
        ant.dat[, x] <- ant.dat[, x] %>% gsub("^.*__", "", .)
        ant.dat[, x] <- paste0(substr(colnames(ant.dat)[x], 1, 1) %>% tolower,
                               "__", ifelse(ant.dat[,x] %>% is.na, "", ant.dat[,x]))
        ant.dat[, x]
    })
    dataset$ant <- ant.dat

    # Metadata table
    met.dat <- dataset$met
    met.idx <- sapply(sam.ord, function(x){ which(met.dat %>% rownames == x) })
    met.dat <- met.dat[met.idx,] %>% as.data.frame()
    if (unique(met.dat %>% rownames == sam.ord) %>% length > 1 ||
        !unique(met.dat %>% rownames == sam.ord)) stop("Failed to sort sample ids in <met>!")
    dataset$met <- met.dat

    # Environmental table
    if(!dataset$env %>% is.null){
        env.dat <- dataset$env
        env.idx <- sapply(sam.ord, function(x){ which(env.dat %>% rownames == x) })
        env.dat <- env.dat[env.idx,] %>% as.data.frame()
        if (unique(env.dat %>% rownames == sam.ord) %>% length > 1 ||
            !unique(env.dat %>% rownames == sam.ord)) stop("Failed to sort sample ids in <env>!")
        dataset$env <- env.dat
    }

    # Spatial data table
    if(!dataset$spa$tabs %>% is.null){
        spa.dat <- dataset$spa$tabs
        spa.idx <- sapply(sam.ord, function(x){ which(spa.dat %>% rownames == x) })
        spa.dat <- spa.dat[spa.idx,] %>% as.data.frame()
        if (unique(spa.dat %>% rownames == sam.ord) %>% length > 1 ||
            !unique(spa.dat %>% rownames == sam.ord)) stop("Failed to sort sample ids in spatial data table!")
        dataset$spa$tabs <- spa.dat
    }

    # Phylogenetic tree
    if(!dataset$phy %>% is.null){
        phy.tre <- dataset$phy
        if(!phy.tre %>% ape::is.rooted()) phy.tre <- phy.tre %>% ape::multi2di() # Toot the phylogenetic tree
        phy.tre %<>% ape::drop.tip(tip = which(!(phy.tre$tip.label %in% rownames(dataset$mat))))
        dataset$phy <- phy.tre
    }
    return(dataset)
}

#' @title Show the summary of a microgeo dataset
#' @author Li Chaonan (Ecological Security and Protection Key Laboratory of Sichuan Province, Mianyang Normal University)
#' @description This function is implemented to show the summary of a microgeo dataset (a `MicrogeoDataset` class).
#' @param dataset A microgeo dataset with the class of `MicrogeoDataset`.
#' @seealso
#' \code{\link[microgeo:read_aliyun_map]{microgeo::read_aliyun_map()}}
#' \code{\link[microgeo:plot_bmap]{microgeo::plot_bmap()}}
#' \code{\link[microgeo:add_label]{microgeo::add_label()}}
#' \code{\link[microgeo:add_scale_bar]{microgeo::add_scale_bar()}}
#' \code{\link[microgeo:add_north_arrow]{microgeo::add_north_arrow()}}
#' \code{\link[microgeo:add_crs]{microgeo::add_crs()}}
#' \code{\link[microgeo:create_dataset]{microgeo::create_dataset()}}
#' @examples
#' data(qtp)
#' map <- read_aliyun_map(adcode = c(540000, 630000, 510000))
#' map %>% plot_bmap() %>%
#'     add_label(dat = map@data, lab.var = 'NAME', lon.var = 'X.CENTER', lat.var = 'Y.CENTER') %>%
#'     add_scale_bar() %>% add_north_arrow() %>% add_crs()
#' dataset.dts <- create_dataset(mat = qtp$asv, ant = qtp$tax, met = qtp$met, map = map,
#'                               phy = qtp$tre, env = qtp$env, lon = "longitude", lat = "latitude")
#' dataset.dts %>% show_dataset()
#' @export
show_dataset = function(dataset){

    # The summary of microgeo dataset
    check_dataset(dataset)
    cli::cat_rule("The Summary of Microgeo Dataset", col = 'blue')
    if (!dataset$mat %>% is.null){
        msg <- "object$mat: "
        if (dataset$mat %>% colSums %>% unique %>% length == 1) {
            subsampled.depth <- dataset$mat %>% colSums %>% unique
            cli::cli_div(theme = list(span.emph = list(color = "green")))
            subsample.reminder <- paste0('[subsample depth: ', subsampled.depth, ']')
            paste0(msg, dataset$mat %>% nrow, " ASVs/genes and ", dataset$mat %>% ncol,
                   " samples {.emph {subsample.reminder}}") %>% cli::cli_alert_info()
        }else{
            cli::cli_div(theme = list(span.emph = list(color = "red")))
            subsample.reminder <- '[need to be subsampled!]'
            paste0(msg, dataset$mat %>% nrow, " ASVs/genes and ", dataset$mat %>% ncol,
                   " samples {.emph {subsample.reminder}}") %>% cli::cli_alert_warning()
        }
    }
    if (!dataset$ant %>% is.null){
        msg <- "object$ant: "
        paste0(msg, dataset$ant %>% nrow, " ASVs/genes and ", dataset$ant %>% ncol,
               " annotation levels (", paste(dataset$ant %>% colnames, collapse = ", "),
               ")") %>% cli::cli_alert_info()
    }
    if (!dataset$met %>% is.null){
        msg <- "object$met: "
        paste0(msg, dataset$met %>% nrow, " samples and ", dataset$met %>% ncol,
               " variables (", paste(dataset$met %>% colnames, collapse = ", "),
               ")") %>% cli::cli_alert_info()
    }
    if (!dataset$map %>% is.null){
        msg <- "object$map: "
        paste0(msg, "a ", dataset$map %>% class, " with the CRS of '",
               dataset$map %>% raster::crs() %>% as.character, "'") %>% cli::cli_alert_info()
    }
    if (!dataset$phy %>% is.null){
        msg <- "object$phy: "
        paste0(msg, "a phylogenetic tree with ", dataset$phy$tip.label %>% length,
               " tip labels") %>% cli::cli_alert_info()
    }
    if (!dataset$env %>% is.null){
        msg <- "object$env: "
        paste0(msg, dataset$env %>% nrow, " samples and ", dataset$env %>% ncol,
               " variables") %>% cli::cli_alert_info()
    }

    # The summary of biogeographic data
    # TODO: if adding the functions for more biogeographic traits, please update the following codes
    if (!dataset$spa %>% is.null |
        !dataset$abd %>% is.null |
        !dataset$div$alpha %>% is.null |
        !dataset$div$beta  %>% is.null |
        !dataset$asb$alpha_phylo %>% is.null |
        !dataset$asb$beta.phylo %>% is.null){
        cat("", fill = TRUE)
        cli::cat_rule("The Summary of Biogeographic Traits", col = 'darkgreen')
    }
    if (!dataset$spa %>% is.null){
        msg <- "object$spa: "
        paste0(msg, dataset$spa$rast$his %>% names %>% length, " historically numeric variables; ",
               dataset$spa$rast$cla %>% names %>% length," historically classification variables; ",
               dataset$spa$rast$fut %>% names %>% length, " groups of future climate data") %>%
            cli::cli_alert_success()
    }
    if (!dataset$abd$raw %>% is.null){
        msg <- "object$abd$raw: "
        paste0(msg, dataset$abd$raw %>% names %>% length,
               " abundance tables (", dataset$abd$raw %>% names %>% paste(., collapse = ", "),
               ")") %>% cli::cli_alert_success()
    }
    if (!dataset$abd$mar %>% is.null){
        msg <- "object$abd$mar: "
        paste0(msg, dataset$abd$mar$abundance %>% ncol, " eco-markers at ", dataset$abd$mar$annotation.level, " level (",
            paste(names(dataset$abd$mar)[which(dataset$abd$mar %>% names != 'annotation.level')], collapse = ", "),
            ")") %>% cli::cli_alert_success()
    }
    if (!dataset$div$alpha %>% is.null){
        msg <- "object$div$alpha: "
        paste0(msg, dataset$div$alpha %>% ncol, " alpha diversity index/indices (",
               paste(dataset$div$alpha %>% colnames, collapse = ', '), ")") %>% cli::cli_alert_success()
    }
    if (!dataset$div$beta %>% is.null){
        msg <- "object$div$beta: "
        paste0(msg, dataset$div$beta %>% length, " beta diversity distance matrix/matrices (",
               paste(dataset$div$beta %>% names, collapse = ', '), ")") %>% cli::cli_alert_success()
    }
    if (!dataset$asb$alpha_phylo %>% is.null){
        msg <- "object$asb$alpha_phylo: "
        paste0(msg, dataset$asb$alpha_phylo %>% ncol, " alpha phylogenetic assembling index/indices (",
               colnames(dataset$asb$alpha_phylo)[1:3] %>% paste(., collapse = ', '), ", ...)") %>%
            cli::cli_alert_success()
    }
    if (!dataset$asb$beta.phylo$raw$result %>% is.null){
        msg <- "object$asb$beta.phylo$raw$result: "
        paste0(msg, dataset$asb$beta.phylo$raw$result %>% ncol, " beta phylogenetic assembling index/indices (",
               colnames(dataset$asb$beta.phylo$raw$result)[1:3] %>% paste(., collapse = ', '), ", ...)") %>%
            cli::cli_alert_success()
    }
    if (!dataset$asb$beta.phylo$dis %>% is.null){
        msg <- "object$asb$beta.phylo$dis: "
        paste0(msg, dataset$asb$beta.phylo$dis %>% length, " beta phylogenetic distance matrix/matrices (",
            paste(dataset$asb$beta.phylo$dis %>% names, collapse = ', '), ")") %>%
            cli::cli_alert_success()
    }
    cat("", fill = TRUE)
    cli::cat_bullet("To check the summary of dataset, Replace `object` with the variable name of your dataset",
                    background_col = 'blue')
    cli::cat_bullet("For example, if the variable name is `dataset.dts`",
                    "you can run `head(dataset.dts$met)` to check the content of `met`", background_col = 'blue')
}
